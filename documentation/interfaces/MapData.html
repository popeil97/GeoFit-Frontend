<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>geo-fit documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">geo-fit documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>MapData</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/map/map.component.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#coords">coords</a>
                                </li>
                                <li>
                                        <a href="#route_pins">route_pins</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="coords"></a>
                                        <span class="name"><b>coords</b><a href="#coords"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>coords:         <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="route_pins"></a>
                                        <span class="name"><b>route_pins</b><a href="#route_pins"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>route_pins:         <code><a href="../interfaces/RoutePins.html" target="_self" >RoutePins[]</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/RoutePins.html" target="_self" >RoutePins[]</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { AfterViewInit, Component, Input, OnInit, OnChanges, SimpleChanges, ChangeDetectorRef, ComponentFactory, ComponentFactoryResolver, RendererFactory2, ViewContainerRef, ApplicationRef } from &#x27;@angular/core&#x27;;
import { NgElement, WithProperties } from &#x27;@angular/elements&#x27;;
import {MatDialog, MatDialogRef, MAT_DIALOG_DATA,MatDialogConfig} from &#x27;@angular/material/dialog&#x27;;
import { UserProfileService } from &#x27;../userprofile.service&#x27;;
//import * as L from &#x27;leaflet&#x27;;
//import * as markercluster from &#x27;leaflet.markercluster&#x27;;
import { PopUpService } from &#x27;../pop-up.service&#x27;;
import { UserFollowComponent } from &#x27;../user-follow/user-follow.component&#x27;;
import { RoutePinDialogComponent } from &#x27;../route-pin-dialog/route-pin-dialog.component&#x27;;
import { MapService } from &#x27;../map.service&#x27;;

import &#x27;leaflet&#x27;;
import &#x27;leaflet.markercluster&#x27;;
import &#x27;leaflet.heat&#x27;;

const L &#x3D; window[&#x27;L&#x27;];
var heat &#x3D; window[&#x27;heat&#x27;]

import * as _ from &#x27;lodash&#x27;;
import * as turf from &#x27;@turf/turf&#x27;;
import { ListKeyManager } from &#x27;@angular/cdk/a11y&#x27;;
import { AppComponent } from &#x27;../app.component&#x27;;
import { PopupComponent } from &#x27;../popup/popup.component&#x27;;
import { RaceService } from &#x27;../race.service&#x27;;

@Component({
  selector: &#x27;app-map&#x27;,
  templateUrl: &#x27;./map.component.html&#x27;,
  styleUrls: [&#x27;./map.component.css&#x27;]
})
export class MapComponent implements AfterViewInit,OnChanges {
  @Input() coordinates;
  @Input() draw:Boolean;
  @Input() displayUsers:Boolean;
  @Input() followedIDs:any;
  @Input() zoom:Boolean;
  @Input() raceID:number;

  private orgData: UserData[];
  private userData: UserData[];
  private myUserDataIdx: number;

  private routePins: RoutePins[];

  public map;
  private line:any;
  private coordsRoutes:any[];

  private markersByUserID &#x3D; {};
  private markerClusters:any;
  private orgMarkerClusters:any;
  private routePinMarkers:any;
  private layerIDsToUserIndices &#x3D; {};
  private layerIDsToOrgIndices &#x3D; {};

  private myMarker: any;

  private marker_start:any;
  private marker_end:any;

  private user_team_or_stat:any;

  private initialized: boolean &#x3D; false;

  //Store user IDs of male and female pins
  private maleIDs: number[];
  private femaleIDs: number[];

  loading:boolean &#x3D; false;

  //We extend the Marker class to set our own &#x27;routePinIndex&#x27; option
  private routePinMarker &#x3D; L.Marker.extend({
    options: {
      routePinIndex: 0,
    }
  });


  constructor(private popupService:PopUpService, 
              private _profileService:UserProfileService,
              private _mapService: MapService,
              private _raceService:RaceService,
              public dialog: MatDialog) {
    this.coordsRoutes &#x3D; [];
    Window[&quot;mapComponent&quot;] &#x3D; this;
  }


  ngOnChanges(changes: SimpleChanges) {
    if (this.initialized){
      for(const propName in changes) {
        if(changes.hasOwnProperty(propName)) {
          switch(propName) {
            case &#x27;raceID&#x27;:
              this.getMapData();
          }
        }
      }
    }
  }


  ngAfterViewInit(): void {
    if(this.map &#x3D;&#x3D; undefined) {
      this.initMap();
    }

    //This ensures we can still use homepage coords if provided via Input
    if (!this.coordinates){
      this.getMapData();
    }
    else {
      this.applyCoordinates();
    }

    this.initialized &#x3D; true;
  }


  public getMapData(){

    this._mapService.getOrgPinStats(this.raceID).then((data) &#x3D;&gt; {
      console.log(&#x27;ORG PINSSSS DATAAAAA&#x27;,data);
      let orgPinData &#x3D; data as OrgPinData;
      this.orgData &#x3D; orgPinData.org_pins;
    })
    
    this._mapService.getMapData(this.raceID).then((data) &#x3D;&gt; {
      let mapData &#x3D; data as MapData;

      //Get and apply coordinates
      this.coordinates &#x3D; mapData.coords;
      this.applyCoordinates();

      //Get and apply route pins
      this.routePins &#x3D; mapData.route_pins;
      if (this.routePins){
        this.createRoutePins();
      }

      this.loading&#x3D;true;

      this._raceService.getUserRacestats(this.raceID).then((data:any) &#x3D;&gt; {
        this.userData &#x3D; data.users_data;
    
        if (this.displayUsers){
          this.createUserPins(false);
        }

        this.loading&#x3D;false;
      });
    });

  }


  public panToUserMarker(user_id, showPopUp&#x3D;true){
    //Do this to simply pan to user pin
    //this.map.panTo(this.markersByUserID[user_id.toString()][&#x27;latLng&#x27;]);

    //Do this to pan *and* zoom
    var markerBounds &#x3D; L.latLngBounds([this.markersByUserID[user_id.toString()][&#x27;latLng&#x27;]]);
    var options &#x3D; {&#x27;maxZoom&#x27;: 15, &#x27;animate&#x27;: true, &#x27;easeLinearity&#x27;: 0.1}
    this.map.fitBounds(markerBounds, options);
  }


  public panToUSA(){
    var corner1 &#x3D; L.latLng(40.4, -73.7);
    var corner2 &#x3D; L.latLng(39.79, -75.5);
    var markerBounds &#x3D; L.latLngBounds(corner1,corner2);
    var options &#x3D; {&#x27;maxZoom&#x27;: 15, &#x27;animate&#x27;: true, &#x27;easeLinearity&#x27;: 0.1}
    this.map.fitBounds(markerBounds, options);
  }


  public panToIsrael(){
    var corner1 &#x3D; L.latLng(31.8,35.3);
    var corner2 &#x3D; L.latLng(31.76, 35.18);
    
    var markerBounds &#x3D; L.latLngBounds(corner1,corner2);
    var options &#x3D; {&#x27;maxZoom&#x27;: 15, &#x27;animate&#x27;: true, &#x27;easeLinearity&#x27;: 0.1}
    this.map.fitBounds(markerBounds, options);
  }


  public clearMap(): void {
    if(this.marker_start &amp;&amp; this.marker_end &amp;&amp; this.line) {
      this.map.removeLayer(this.marker_start);
      this.map.removeLayer(this.marker_end);
      this.map.removeLayer(this.line);
    }
  }


  private applyCoordinates():void {
    if(!this.map) {
      this.initMap()
    }

    //ugly but neccessary way of adding start pins and paths to map
    var temp_routes &#x3D; [];
    var temp_coords &#x3D; [];
    var temp_routes_flipped &#x3D; [];
    var temp_coords_flipped &#x3D; [];

    _.forEach(this.coordinates,(route) &#x3D;&gt; {
      temp_coords &#x3D; [];
      temp_coords_flipped &#x3D; [];

      _.forEach(route.coords, (coord) &#x3D;&gt; {
        temp_coords.push([coord[0], coord[1]]);
        temp_coords_flipped.push([coord[1], coord[0]]);
      })

      temp_routes.push(temp_coords);
      temp_routes_flipped.push(temp_coords_flipped);
    });

    let start_coord &#x3D; temp_routes_flipped[0][0];
    let final_route &#x3D; temp_routes_flipped[temp_routes_flipped.length-1];
    let end_coord &#x3D; final_route[final_route.length-1];

    let begin &#x3D; new L.LatLng(start_coord[0], start_coord[1]);
    let finish &#x3D; new L.LatLng(end_coord[0], end_coord[1]);
    let bounds &#x3D; new L.LatLngBounds(begin, finish);

    this.map.fitBounds(bounds, { padding: [15, 15] });

    const lat &#x3D; 29.651634;
    const lon &#x3D; -82.324829;
    this.marker_start &#x3D; L.marker(start_coord,{icon: L.icon({
      iconSize: [ 25, 41 ],
      iconAnchor: [10, 40],
      popupAnchor: [18, -40],
      iconUrl: &#x27;leaflet/marker-icon.png&#x27;,
      shadowUrl: &#x27;leaflet/marker-shadow.png&#x27;,
    })}).addTo(this.map);

    this.marker_start.bindPopup(this.popupService.makePopup({name:&#x27;Start&#x27;,state:&#x27;Jerusalem&#x27;}));

    this.marker_end &#x3D; L.marker(end_coord,{icon: L.icon({
      iconSize: [ 38, 36 ],
      iconAnchor: [10, 40],
      popupAnchor: [18, -40],
      iconUrl: &#x27;https://tucan-prod-bucket.s3-us-west-2.amazonaws.com/media/endflag.png&#x27;,
      shadowUrl: &#x27;leaflet/marker-shadow.png&#x27;,
    })}).addTo(this.map);

    this.marker_end.bindPopup(this.popupService.makePopup({name:&#x27;End&#x27;,state:&#x27;Philadelphia&#x27;}));

    if(this.zoom)
    {
      this.map.setView([45, -100], 4);
    }
    
    if(this.zoom)
    {
      var color &#x3D; &quot;#BC164D&quot;;
    }
    else
    {
      var color &#x3D; &quot;blue&quot;;
    }

    //Add each path to map independently
    _.forEach(temp_routes_flipped,(route) &#x3D;&gt; {
      this.line &#x3D; L.polyline(route,{
        color: color,
        weight: 8,
        opacity: 0.65
      }).addTo(this.map);
    });

    //We store coordinates in their original order 
    //so we can work out user progression along route later
    let count &#x3D; 1;
    _.forEach(temp_routes, (route) &#x3D;&gt; {
      let name &#x3D; &#x27;route&#x27; + count.toString();
      this.coordsRoutes.push(turf.lineString(route, { name: name }));
      count +&#x3D; 1;
    })
  }


  private union_arrays (x, y) {
    var obj &#x3D; {};
    for (var i &#x3D; x.length-1; i &gt;&#x3D; 0; -- i)
       obj[x[i]] &#x3D; x[i];
    for (var i &#x3D; y.length-1; i &gt;&#x3D; 0; -- i)
       obj[y[i]] &#x3D; y[i];
    var res &#x3D; []
    for (var k in obj) {
      if (obj.hasOwnProperty(k))  // &lt;-- optional
        res.push(obj[k]);
    }
    return res;
  }


  public showPinsFromSettings(settings: PinSettings){
    //If showing org pins, this overrides all other settings
    if (settings.showOrgPins){
      this.createOrgPins();
      return;
    }

    //If we instead wish to show all user pins, simply call createUserPins()
    if (settings.allAgesOn &amp;&amp; settings.malePinsOn &amp;&amp; settings.femalePinsOn &amp;&amp; !settings.followerPinsOnly){
      this.createUserPins(false);
      return;
    }

    //If user selects more granular options, we have to collect IDs corresponding to users
    //within user selection bounds, and plot the pins of only these users
    
    let unionIDs &#x3D; [];
    let maleIDs &#x3D; [];
    let femaleIDs &#x3D; [];
    
    //We do this so if both M and F are checked, people of all genders
    //are displayed
    if (!settings.malePinsOn || !settings.femalePinsOn){
      if (settings.malePinsOn){
        maleIDs &#x3D; this.getIDsByGender(&#x27;Male&#x27;);
      }
      if (settings.femalePinsOn){
        femaleIDs &#x3D; this.getIDsByGender(&#x27;Female&#x27;);
      }

      console.log(&quot;female IDs: &quot;, femaleIDs);
      
      unionIDs &#x3D; maleIDs.concat(femaleIDs);
      console.log(&quot;Union IDs: &quot;, unionIDs);

    }

    //Limit to only users we follow
    if (settings.followerPinsOnly){
      if (unionIDs.length){
        unionIDs &#x3D; unionIDs.filter(value &#x3D;&gt; this.followedIDs.includes(value));
      }
      else {
        unionIDs &#x3D; this.followedIDs;
      }
    }

    //Limit by age group
    if (!settings.allAgesOn){
      let ageIDs &#x3D; this.getIDsInAgeRange(settings.minAge, settings.maxAge);
      if (unionIDs.length){
        unionIDs &#x3D; unionIDs.filter(value &#x3D;&gt; ageIDs.includes(value));
      }
      else {
        unionIDs &#x3D; ageIDs;
      }
    }

    console.log(&quot;Union IDs: &quot;, unionIDs);

    this.showPinsByID(unionIDs, false);
  }

  public showAllPins(){
    this.showPinsByID(null, true);
  }


  public getIDsInAgeRange(minAge: number, maxAge: number){
    let IDs &#x3D; [];
    for (let i &#x3D; 0; i &lt; this.userData.length; i++){
      if (this.userData[i].age &gt;&#x3D; minAge &amp;&amp; this.userData[i].age &lt;&#x3D; maxAge){
        IDs.push(this.userData[i].user_id);
      }
    }

    return IDs;
  }


  public getIDsByGender(gender: string){
    let IDs &#x3D; [];
    for (let i &#x3D; 0; i &lt; this.userData.length; i++){
      if (this.userData[i].gender &#x3D;&#x3D; gender){
        IDs.push(this.userData[i].user_id);
      }
    }

    return IDs;
  }


  public clearUserPins(){
    //Remove all current user pins
    if (this.markerClusters){
      this.map.removeLayer(this.markerClusters);
    }
  }

  
  public clearOrgPins(){
    if (this.orgMarkerClusters){
      this.map.removeLayer(this.orgMarkerClusters);
    }
  }


  public showPinsByID(IDs, showAll: boolean){
    //Clear all user and org pins
    this.clearUserPins();
    this.clearOrgPins();

    console.log(&quot;IDs to show: &quot;, IDs);

    let viewComponent &#x3D; this;

    this.map.removeLayer(this.markerClusters);

    this.markerClusters.eachLayer(function(layer) {
      let tempUserDataIndex &#x3D; viewComponent.layerIDsToUserIndices[layer._leaflet_id.toString()];
      let tempUserData &#x3D; viewComponent.userData[tempUserDataIndex];
      console.log(&quot;user data: &quot;, viewComponent.userData);
      console.log(&quot;User data index: &quot;, tempUserDataIndex);
      console.log(&quot;layerIDstouserindices: &quot;, viewComponent.layerIDsToUserIndices);
      let pinUserID &#x3D; tempUserData.user_id;

      if (showAll &#x3D;&#x3D; true || IDs.includes(pinUserID)){
        layer.addTo(viewComponent.map);
      }
      else {
        layer.remove();
      }
    });
  }


  public createMarkerClusterGroup(maxMarkers: number){
    return L.markerClusterGroup({
      //disableClusteringAtZoom: 12, //12
      maxClusterRadius: 20, //20
      animateAddingMarkers: true,
      iconCreateFunction: function(cluster){
          var markers &#x3D; cluster.getAllChildMarkers();

          //Maximum of 4 imgs per cluster (choose first 4 children)
          var markersInCluster &#x3D; Math.min(maxMarkers, markers.length);

          var inner_html &#x3D; &#x27;&#x27;;

          for (let i &#x3D; 0; i &lt; markersInCluster; i++){
            var img_class &#x3D; &#x27;pos&#x27; + (i).toString() + &#x27;of&#x27; + markersInCluster.toString();

            var content &#x3D; markers[i][&#x27;options&#x27;][&#x27;icon&#x27;][&#x27;options&#x27;][&#x27;html&#x27;]
            var regex &#x3D; /&lt;img.*?src&#x3D;[&#x27;&quot;](.*?)[&#x27;&quot;]/;
            var img_src &#x3D; regex.exec(content)[1];

            inner_html +&#x3D; &quot;&lt;img class&#x3D;\&quot;&quot; + img_class + &quot;\&quot; src&#x3D;\&quot;&quot; + img_src + &quot;\&quot;&gt;&quot;
          }

          //Remember to add the pin to the cluster pin
          inner_html +&#x3D; &#x27;&lt;div class&#x3D;&quot;pin&quot;&gt;&lt;/div&gt;&#x27;;

          var divClass &#x3D; &#x27;cluster-pin-&#x27; + markersInCluster.toString();

          return L.divIcon({
            className: divClass,
            html: inner_html,
            iconSize: [30, 30],
            iconAnchor: [10, 33],
            popupAnchor: [0, -62],
          });
        }
    });
  }


  //Updates the logged in users stat and recreates *all* pins
  public updateMyUserStatAndCreatePins(){
    //Update our user data item in array
    this._raceService.getTeamOrUserStat(this.raceID).then((data) &#x3D;&gt; {
      let userData &#x3D; data as UserData;
      this.userData[this.myUserDataIdx] &#x3D; userData;

      //Reshow all pins
      this.createUserPins(false);
    });
  }


  public createUserPins(heatMapOn){
    //Clear all user and org pins
    this.clearUserPins();
    this.clearOrgPins();

    //Set max number of markers in a cluster and set up clustering
    var maxMarkersInCluster &#x3D; 4;
    this.markerClusters &#x3D; this.createMarkerClusterGroup(maxMarkersInCluster);

    //var heatArray &#x3D; new Array(this.userData.length);

    //Iterate over user data, create and show pins and retain map of leaflet ID -&gt; user idx
    for (var i &#x3D; 0; i &lt; this.userData.length; i++){
      // heatArray[i] &#x3D; [lat_user,lng_user,1]
      // heatArray[i+this.userData.length] &#x3D; [lat_user,lng_user,1.0]
      let user_leaflet_id &#x3D; this.createPin(this.userData[i]);
      this.layerIDsToUserIndices[user_leaflet_id] &#x3D; i;

      if (this.isMe(this.userData[i])){
        this.myUserDataIdx &#x3D; i;
      }
    }

    //Add pin clusters to map
    this.map.addLayer(this.markerClusters);

    //Bind everybody&#x27;s Popupcomponent to their Popup
    //If popup is ours, we open it up by default
    let thisComponent &#x3D; this;
    this.markerClusters.eachLayer(function(layer) {
      let tempUserDataIndex &#x3D; thisComponent.layerIDsToUserIndices[layer._leaflet_id.toString()];
      let tempUserData &#x3D; thisComponent.userData[tempUserDataIndex];

      layer.bindPopup( layer &#x3D;&gt; { const popupEl: NgElement &amp; WithProperties&lt;PopupComponent&gt; &#x3D; document.createElement(&#x27;popup-element&#x27;) as any;
                                      popupEl.userData &#x3D; tempUserData;
                                      document.body.appendChild(popupEl);
                                      return popupEl}, {
                                        &#x27;autoClose&#x27;: false,
                                      })

      if (layer._leaflet_id &#x3D;&#x3D; Object.keys(thisComponent.myMarker._layers)[0]){
        thisComponent.markerClusters.zoomToShowLayer(layer, function() {
          layer.openPopup();
        });
      }
    })

    //Handle marker onclick events (open popups)
    this.markerClusters.on(&#x27;click&#x27;, function(ev) {
      if (!ev.layer.getPopup()._isOpen){
        //Open popup if it is already binded
        ev.layer.getPopup().openPopup();
      }

      else {
        //If popup open before click, close it
        ev.layer.getPopup().closePopup();
      }

    });

    // heatArray &#x3D; heatArray.map(function (p) { return [p[0], p[1]]; });

    // if(heatMapOn)
    // {
    //   try{
    //     heat.remove();
    //   }
    //   catch(ex){}
      
    //   heat &#x3D; L.heatLayer(heatArray, {radius: 50},{minOpacity: 1.0}).addTo(this.map);
    // }
    // else
    // {
    //   try{
    //     heat.remove();
    //   }
    //   catch(ex){}
    // }
  }

  
  public createOrgPins() {
    console.log(&quot;Creating org pins&quot;);

    //Clear all user and org pins
    this.clearUserPins();
    this.clearOrgPins();

    //Set max number of markers in a cluster and set up clustering
    var maxMarkersInCluster &#x3D; 4;
    this.orgMarkerClusters &#x3D; this.createMarkerClusterGroup(maxMarkersInCluster);

    //Iterate over user data, create and show pins and retain map of leaflet ID -&gt; user idx
    for (var i &#x3D; 0; i &lt; this.orgData.length; i++){
      console.log(&quot;Creating pin with data &quot;, this.orgData[i]);
      let user_leaflet_id &#x3D; this.createPin(this.orgData[i], true);
      this.layerIDsToOrgIndices[user_leaflet_id] &#x3D; i;
    }

    //Add pin clusters to map
    this.map.addLayer(this.orgMarkerClusters);

    //Bind everybody&#x27;s Popupcomponent to their Popup
    //If popup is ours, we open it up by default
    let thisComponent &#x3D; this;
    this.orgMarkerClusters.eachLayer(function(layer) {
      let tempOrgDataIndex &#x3D; thisComponent.layerIDsToOrgIndices[layer._leaflet_id.toString()];
      let tempOrgData &#x3D; thisComponent.orgData[tempOrgDataIndex];

      layer.bindPopup( layer &#x3D;&gt; { const popupEl: NgElement &amp; WithProperties&lt;PopupComponent&gt; &#x3D; document.createElement(&#x27;popup-element&#x27;) as any;
                                      popupEl.userData &#x3D; tempOrgData;
                                      popupEl.isTag &#x3D; true;
                                      document.body.appendChild(popupEl);
                                      return popupEl}, {
                                        &#x27;autoClose&#x27;: false,
                                      })
    })

    //Handle marker onclick events (open popups)
    this.orgMarkerClusters.on(&#x27;click&#x27;, function(ev) {
      if (!ev.layer.getPopup()._isOpen){
        //Open popup if it is already binded
        ev.layer.getPopup().openPopup();
      }

      else {
        //If popup open before click, close it
        ev.layer.getPopup().closePopup();
      }

    });
  }
  

  public createPin(userData: UserData, isTag: boolean&#x3D;false){
    var img_html &#x3D; &quot;&lt;img src&#x3D;\&quot;&quot; + userData.profile_url + &quot;\&quot;;\&quot;&gt;&lt;div class&#x3D;\&quot;pin\&quot;&gt;&lt;/div&gt;&lt;div class&#x3D;\&quot;pulse\&quot;&gt;&lt;/div&gt;&quot;;

    var userIcon &#x3D; L.divIcon({
      className: &#x27;location-pin&#x27;,
      html: img_html,
      iconSize: [30, 30],
      iconAnchor: [10, 33],
      popupAnchor: [0, -62],
    });

    var user_rel_miles &#x3D; userData.rel_distance;
    var user_route_idx &#x3D; userData.route_idx;

    //Get user&#x27;s distance type for turf
    var distanceTypeOptions;
    if (userData.distance_type &#x3D;&#x3D; &#x27;MI&#x27;){
      distanceTypeOptions &#x3D; {units: &#x27;miles&#x27;};
    }
    else {
      distanceTypeOptions &#x3D; {units: &#x27;kilometers&#x27;};
    }

    var along_user &#x3D; turf.along(this.coordsRoutes[user_route_idx], user_rel_miles, distanceTypeOptions);

    var lng_user &#x3D; along_user.geometry.coordinates[0];
    var lat_user &#x3D; along_user.geometry.coordinates[1];

    var locMarker &#x3D; L.geoJSON(along_user, {
      pointToLayer: function(feature, latlng) {
        return L.marker(latlng, { icon: userIcon });
      }
    })

    if (isTag){
      this.orgMarkerClusters.addLayer(locMarker);
    }
    else {
      //Get user ID of this race stat
      let elementID &#x3D; userData.user_id;

      this.markerClusters.addLayer(locMarker);

      //Retain markers in dict so we can pan to it upon select
      this.markersByUserID[elementID] &#x3D; {
          &#x27;locMarker&#x27; : locMarker,
          &#x27;latLng&#x27; : L.latLng(lat_user, lng_user),
      };

      //If this pin is current user, pan and zoom to it
      if (this.isMe(userData)){
        this.myMarker &#x3D; this.markersByUserID[elementID][&#x27;locMarker&#x27;];
        this.panToUserMarker(elementID);
      }
    }

    //Return leaflet id
    let user_leaflet_id &#x3D; Object.keys(locMarker._layers)[0].toString()
    return user_leaflet_id;
  }


  private isMe(userData: any){
    if (userData.isMe){
      return true;
    }
    else if (userData.child_user_stats){
      for (let i &#x3D; 0; i &lt; userData.child_user_stats.length; i++){
        if (userData.child_user_stats[i].isMe){
          return true;
        }
      }
    }

    return false;
  }


  private openRoutePinDialogueWithIndex(index: number, thisComponent: any){
    let dialogRef &#x3D; thisComponent.dialog.open(RoutePinDialogComponent, {
      data: { 
        &#x27;title&#x27;: thisComponent.routePins[index].title,
        &#x27;description&#x27;: thisComponent.routePins[index].description,
        &#x27;image_urls&#x27;: thisComponent.routePins[index].image_urls,
      },
    });
  }


  private createRoutePins(){
    this.routePinMarkers &#x3D; new L.featureGroup();

    for (let i &#x3D; 0; i &lt; this.routePins.length; i++){
      var img_html &#x3D; &quot;&lt;img src&#x3D;\&quot;&quot; + this.routePins[i].image_urls[0] + &quot;\&quot;;\&quot;&gt;&lt;div class&#x3D;\&quot;rounded-pin\&quot;&gt;&lt;/div&gt;&quot;;
      var userIcon &#x3D; L.divIcon({
        className: &#x27;route-pin&#x27;,
        html: img_html,
        iconSize: [30, 30],
        iconAnchor: [10, 33],
        popupAnchor: [0, -62],
      });  

      var latlng &#x3D; new L.LatLng(this.routePins[i].lat, this.routePins[i].lon);

      var routeMarker &#x3D; new this.routePinMarker(latlng, { 
        icon: userIcon,
        routePinIndex: i });

      this.routePinMarkers.addLayer(routeMarker);
    }

    this.routePinMarkers.addTo(this.map);

    //Handle marker onclick events (open popups)
    let thisComponent &#x3D; this;
    this.routePinMarkers.on(&#x27;click&#x27;, function(ev) {
      thisComponent.openRoutePinDialogueWithIndex(ev.layer.options.routePinIndex, thisComponent);
    });
    
  }


  private initMap(): void {
    this.map &#x3D; L.map(&#x27;map&#x27;, { zoomControl: false });

    // const tiles &#x3D; L.tileLayer(&#x27;https://tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{y}{r}.png&#x27;, {
    //   maxZoom: 19,
    //   attribution: &#x27;&amp;copy; &lt;a href&#x3D;&quot;http://www.openstreetmap.org/copyright&quot;&gt;OpenStreetMap&lt;/a&gt;&#x27;
    // });

    // tiles.addTo(this.map);

    const tiles &#x3D; L.tileLayer(&#x27;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#x27;, {
      maxZoom: 19,
      attribution: &#x27;&amp;copy; &lt;a href&#x3D;&quot;http://www.openstreetmap.org/copyright&quot;&gt;OpenStreetMap&lt;/a&gt;&#x27;
    });

    tiles.addTo(this.map);

    new L.Control.Zoom({ position: &quot;topright&quot; }).addTo(this.map);

    //An extract of address points from the LINZ bulk extract: http://www.linz.govt.nz/survey-titles/landonline-data/landonline-bde
//Should be this data set: http://data.linz.govt.nz/#/layer/779-nz-street-address-electoral/
  }


}

interface PinSettings {
  followerPinsOnly: boolean;
  malePinsOn: boolean;
  femalePinsOn: boolean;
  allAgesOn: boolean;
  minAge: number;
  maxAge: number;
  showOrgPins: boolean;
}

interface RoutePins {
  title: string;
  desciption: string;
  lon: number;
  lat: number;
  image_urls: string[];
}

interface MapData {
  coords: any;
  route_pins: RoutePins[];
}

interface UserData {
  user_id: number,
  total_distance: number,
  distance_type: string,
  rel_distance: number,
  route_idx: number,
  display_name: string,
  profile_url: string,
  follows: boolean,
  child_user_stats: any[],
  isTeam: boolean,
  isMe: boolean,
  gender: string,
  age: number,
  description: string,
}

interface OrgPinData {
  org_pins: UserData[];
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'MapData.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
